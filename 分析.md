-   作用域链
    -   会被保存在一个隐式的属性中去[[scoped]] 这个属性是用户访问不到的，但是是的的确确存在的，让 js 引擎来访问的， 里面的存储的就是作用域链 AO GO AO 和 GO 的集合

# JS 的运行机制

js 是单线程的

# arguments 的对象是什么？

-   箭头函数是没有 arguments 对象的

```js
function get() {
    console.log(arguments)
}

get(1, 2, 3)
Array.prototype.slice.call(arguments)
```

类数组对象 转换为数组

# 哪些操作会造成内存泄漏？

-   闭包
-   意外的全局变量
-   被遗忘的定时器
-   脱离 dom 的引用

# 什么是高阶函数？

-   将函数作为参数或者返回值的函数

```js
function highOrder(parames, callback) {
    return callback(params)
}
```

# 手动实现`Array.prototype.map 方法`

promise async await 的异步操作的时候会加入到微任务中去 会在调用栈清空的时候立即执行
调用栈中加入的微任务会立马执行

微任务>消息队列

```js
var p = new Promise((resolve) => {
    console.log(4)
    resolve(5)
})
function func1() {
    console.log(1)
}
function func2() {
    setTimeout(() => {
        console.log(2)
    }, 0)
    func1()
    console.log(3)
    p.then((resolve) => {
        console.log(resolve)
    })
}
// 4 1 3 5 2
```

## 数组的扁平化处理（将多维数组变为一维数组）

```js
const arr = [1, [2, [3, [4, 5]]], 6]
```

### **方法一：使用 flat()**

```js
// 使用数组自带的扁平化方法
const res1 = arr.flat(Infinity)
```

### **方法二：使用正则**

```js
const res2 = JSON.parse('[' + JSON.stringify(arr).replace(/\[|\]/g, '') + ']')
```

### **方法三：使用 reduce**

```js
/*
reduce方法
*/
arr.reduce(function(prev,cur,index,arr){
    ...
},init);
// 或者
arr.reduce(function(prev,cur,index,arr){
    ...
},);

- arr 表示将要原数组；
- prev 表示上一次调用回调时的返回值，或者初始值init;
- cur 表示当前正在处理的数组元素；
- index 表示索引 提供init时索引为0, 否则索引为1;
- init 表示初始值

常用的只有prev和cur

- 数组求和，求乘积
- 计算数组中每个元素出现的次数
let person = ['王一博', '张艺兴', '房东的猫', '陈伟霆', '杨幂', '黄明昊']
let nameNum = person.reduce((pre, cur) => {
    if (cur in pre) {
        pre[cur]++
    } else {
        pre[cur] = 1
    }
    return pre
}, {})

console.log(nameNum)

- 数组去重
  var arr3 = [1, 2, 3, 4, 5, 6, 78, 2, 3, 4]

  var resNew = arr3.reduce((pre, cur) => {
      if (!pre.includes(cur)) {
          return pre.concat(cur)
      } else {
          return pre
      }
  })
console.log(resNew)
- 将二维数组转为一维数组
- 将多维数组转为一维数组
- 对象里的属性求和

const flatten = (arr) => {
    return arr.reduce((pre, cur) => {
        return pre.concat(Array.isArray(cur) ? flatten(cur) : cur)
    }, [])
}
const res4 = flatten(arr)
```

### **方法四：函数递归**

```js
// 1 新建一个数组
// 2 有一个函数 对arr进行遍历
const res4 = []
const fn = (arr) => {
    for (let i = 0; i < arr.length; i++) {
        // 如果是一个数组 就进行循环 如果不是就push进去
        if (Array.isArray(arr[i])) {
            fn(arr[i])
        } else {
            res4.push(arr[i])
        }
    }
}
fn(arr)
```

# BFC 的理解

块级格式化上下文 指的是一个独立的块级渲染区域，该区域有一套规则，与区域外部无关。

# 现象

一个盒子不设置 height，当内容元素浮动时，无法撑起自身，这个盒子没有形成 BFC

# 如何创建 BFC

-   方法 1：float 的值不是 none
-   方法 2：position 的值不是 static 或者 relative
-   方法 3：display 的值是 inline-block、flex 或者 inline-flex
-   方法 4：overflow: hidden

# BFC 解决的问题

-   取消盒子的高度塌陷：当子元素设置外边距的时候会将父元素的也一并带下来
-   可以阻止元素被浮动元素覆盖

# call apply bind
- call、apply会立刻执行 而bind不会

# call apply bind应用
- 1 将伪数组转化为数组 js中的伪数组：argument、dom节点、将类数组转化为真正的数组、数组的拼接

```js
// dom节点
// 不适用IE8以下
let div = document.getElementByTagName('div')
console.log('div')

let arr2 = Array.prototype.slice.call(div)
console.log('arr2')

// argument
function fn() {
    console.log(argument)
    console.log(Array.prototype.slice.call(arguments))
}
fn(1, 2, 3, 4, 5)

// 将类数组转化为真正的数组
let obj1 = {
    0: 1,
    1: '张艺兴',
    2: '刘宪华',
    length: 3 // 一定要有
}

console.log(Array.prototype.slice.call(obj1))
```